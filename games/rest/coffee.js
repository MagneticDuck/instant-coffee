// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var BSHead = function() {
	this.bitIndex = 0;
	this.blockIndex = 0;
};
BSHead.__name__ = true;
BSHead.prototype = {
	read: function(data) {
		if(data.length <= this.blockIndex) {
			return haxe_ds_Option.None;
		} else {
			return haxe_ds_Option.Some((data[this.blockIndex] >> this.bitIndex & 1) == 1);
		}
	}
	,write: function(data,value) {
		while(data.length <= this.blockIndex) data.push(0);
		if(value) {
			data[this.blockIndex] |= 1 << this.bitIndex;
		}
	}
	,increment: function() {
		this.bitIndex += 1;
		if(this.bitIndex > 5) {
			this.bitIndex = 0;
			this.blockIndex += 1;
		}
	}
};
var BSWriter = function() {
	this.head = new BSHead();
	this.data = [];
};
BSWriter.__name__ = true;
BSWriter.prototype = {
	toString: function() {
		var str = "";
		var _g = 0;
		var _g1 = this.data;
		while(_g < _g1.length) {
			var digit = _g1[_g];
			++_g;
			str += haxe_crypto_Base64.CHARS.charAt(digit);
		}
		return str;
	}
	,writeInt: function(value,bits) {
		var _g1 = 0;
		var _g = bits;
		while(_g1 < _g) {
			var i = _g1++;
			this.write([(value >> i & 1) == 1]);
		}
	}
	,write: function(values) {
		var _g = 0;
		while(_g < values.length) {
			var value = values[_g];
			++_g;
			this.head.write(this.data,value);
			this.head.increment();
		}
	}
};
var BSReader = function(encoded) {
	this.head = new BSHead();
	this.data = [];
	var _g1 = 0;
	var _g = encoded.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.data.push(this.charToInt(encoded.charAt(i)));
	}
};
BSReader.__name__ = true;
BSReader.prototype = {
	charToInt: function($char) {
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			if(haxe_crypto_Base64.CHARS.charAt(i) == $char) {
				return i;
			}
		}
		throw new js__$Boot_HaxeError("base64 out of bounds");
	}
	,read: function(length) {
		var bits = [];
		var _g1 = 0;
		var _g = length;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = this.head.read(this.data);
			switch(_g2[1]) {
			case 0:
				var bit = _g2[2];
				bits.push(bit);
				break;
			case 1:
				return haxe_ds_Option.None;
			}
			this.head.increment();
		}
		return haxe_ds_Option.Some(bits);
	}
	,readInt: function(length) {
		var _g = this.read(length);
		switch(_g[1]) {
		case 0:
			var bits = _g[2];
			var sum = 0;
			var _g1 = 0;
			var _g2 = length;
			while(_g1 < _g2) {
				var i = _g1++;
				sum += (bits[i] ? 1 : 0) << i;
			}
			return haxe_ds_Option.Some(sum);
		case 1:
			return haxe_ds_Option.None;
		}
	}
};
var PlayControl = function() {
	this.silent = false;
	this.speed = 0;
	this.paused = false;
	this.frame = 0;
};
PlayControl.__name__ = true;
PlayControl.prototype = {
	pause: function() {
		this.paused = true;
		this.speed = 0;
	}
};
var Engine = function() {
	this.initialDirection = 0;
	this.fakeTime = 0;
	this.pausedCallback = haxe_ds_Option.None;
	this.fullgameVideo = null;
	this.recording = new VideoRecorder(0);
	this.playback = haxe_ds_Option.None;
	this.control = new PlayControl();
	this.frameLength = 16;
	var _gthis = this;
	this._requestAnimationFrame = ($_=window,$bind($_,$_.requestAnimationFrame));
	this._now = ($_=window.performance,$bind($_,$_.now));
	window.requestAnimationFrame = $bind(this,this.requestAnimationFrame);
	window.performance.now = function() {
		return _gthis.fakeTime;
	};
	window._keyup = $bind(this,this.keyup);
	window._keydown = $bind(this,this.keydown);
	window.load = function(string) {
		_gthis.slots[0] = new Video(string);
	};
	window.loadFullgame = function(string1) {
		_gthis.fullgameVideo = JSON.parse(string1);
	};
	window.clearFullgame = function(string2) {
		_gthis.fullgameVideo = null;
	};
	window.startLeft = function() {
		_gthis.initialDirection = 1;
	};
	window.startRight = function() {
		_gthis.initialDirection = 2;
	};
	window.startNeutral = function() {
		_gthis.initialDirection = 0;
	};
	window.useFrame = function(fl) {
		_gthis.frameLength = fl;
	};
	window.coffee = { };
	window.coffee.onScene = $bind(this,this.onScene);
	this.fakeTime = this._now();
	this.slots = [];
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		this.slots.push(new Video());
	}
	this.control.speed = 1;
};
Engine.__name__ = true;
Engine.prototype = {
	wrapCallback: function(callback) {
		var _gthis = this;
		return function() {
			_gthis.fakeTime += _gthis.frameLength;
			var _g = _gthis.playback;
			switch(_g[1]) {
			case 0:
				var player = _g[2];
				var _g1 = 0;
				var _g11 = player.getActions(_gthis.control.frame);
				while(_g1 < _g11.length) {
					var action = _g11[_g1];
					++_g1;
					_gthis.sendGameInput(action.code,action.down);
				}
				if(_gthis.control.frame + 1 >= player.video.pauseFrame) {
					if(_gthis.fullgameVideo == null) {
						_gthis.control.pause();
						console.log("[PAUSE ] @ " + (_gthis.control.frame + 1));
						_gthis.control.silent = false;
					}
					_gthis.playback = haxe_ds_Option.None;
				}
				callback(_gthis.fakeTime);
				break;
			case 1:
				callback(_gthis.fakeTime);
				break;
			}
			_gthis.control.frame += 1;
		};
	}
	,requestAnimationFrame: function(callback) {
		var wrappedCallback = this.wrapCallback(callback);
		if(!this.control.paused) {
			var _g = this.control.speed;
			switch(_g) {
			case 0:
				window.setTimeout(wrappedCallback,100);
				break;
			case 1:
				this._requestAnimationFrame(wrappedCallback);
				break;
			default:
				window.setTimeout(wrappedCallback,0);
			}
		} else {
			this.pausedCallback = haxe_ds_Option.Some(wrappedCallback);
		}
	}
	,triggerPausedCallback: function() {
		var _g = this.pausedCallback;
		switch(_g[1]) {
		case 0:
			var cb = _g[2];
			this.pausedCallback = haxe_ds_Option.None;
			cb();
			break;
		case 1:
			break;
		}
	}
	,keyup: function(callback) {
		var _gthis = this;
		this.keyupHandler = callback;
		window.onkeyup = function(key) {
			_gthis.onKey(key,false);
		};
	}
	,keydown: function(callback) {
		var _gthis = this;
		this.keydownHandler = callback;
		window.onkeydown = function(key) {
			_gthis.onKey(key,true);
		};
	}
	,onKey: function(event,down) {
		if(!Util.isSome(this.playback)) {
			if(Video.keyCodes.indexOf(event.keyCode) != -1) {
				this.sendGameInput(event.keyCode,down);
			}
		}
		if(down) {
			var _g = KeyBindings.fromKeyCode(event.keyCode);
			if(_g[1] == 0) {
				var input = _g[2];
				if(this.handleInterfaceInput(input,event.ctrlKey,event.altKey)) {
					event.preventDefault();
				}
			}
		}
	}
	,sendGameInput: function(keyCode,down) {
		this.recording.recordKey(this.control.frame,keyCode,down,this.control.silent);
		var event = { which : keyCode, preventDefault : function() {
		}};
		if(down) {
			this.keydownHandler(event);
		} else {
			this.keyupHandler(event);
		}
	}
	,primeControls: function(buffer) {
		var _g = 0;
		var _g1 = Video.keyCodes;
		while(_g < _g1.length) {
			var code = _g1[_g];
			++_g;
			this.sendGameInput(code,false);
		}
		if(this.initialDirection == 1) {
			if(buffer) {
				console.log("---> Holding controls: LEFT.");
			}
			this.sendGameInput(37,true);
		}
		if(this.initialDirection == 2) {
			if(buffer) {
				console.log("---> Holding controls: RIGHT.");
			}
			this.sendGameInput(39,true);
		}
		if(this.initialDirection == 0) {
			if(buffer) {
				console.log("---> Holding controls: NONE.");
			}
		}
	}
	,resetLevel: function(slot,replay) {
		if(replay == null) {
			replay = false;
		}
		console.log("[" + (replay ? "REPLAY" : "RESET to") + " " + (slot == null ? "start" : "slot " + (slot == null ? "null" : "" + slot) + "...") + "]");
		this.sendGameInput(82,true);
		this.sendGameInput(82,false);
		this.recording = new VideoRecorder(this.initialDirection);
		this.control = new PlayControl();
		this.primeControls(true);
	}
	,loadPlayback: function(video) {
		this.playback = haxe_ds_Option.Some(new VideoPlayer(video));
		this.initialDirection = video.initialDirection;
		this.recording = new VideoRecorder(this.initialDirection);
	}
	,handleInterfaceInput: function(input,ctrlKey,altKey) {
		var oldControl = JSON.parse(JSON.stringify(this.control));
		if(input == CoffeeInput.StepFrame && this.control.paused) {
			console.log("[STEP  ] @ " + (this.control.frame + 1));
			this.triggerPausedCallback();
			return true;
		}
		if(input == CoffeeInput.Pause) {
			if(!oldControl.paused) {
				console.log("[PAUSE ] @ " + (this.control.frame + 1));
			}
			this.control.pause();
			return true;
		}
		var playAction = true;
		switch(input[1]) {
		case 2:
			this.control.speed = 0;
			break;
		case 3:
			this.control.speed = 1;
			break;
		case 4:
			this.control.speed = 2;
			break;
		default:
			playAction = false;
		}
		if(playAction) {
			this.control.paused = false;
			if(oldControl.paused) {
				console.log("[PLAY  ] @ " + this.control.frame);
			}
			this.triggerPausedCallback();
			return true;
		}
		if(input == CoffeeInput.Reset) {
			this.playback = haxe_ds_Option.None;
			this.resetLevel();
			this.control.pause();
			this.triggerPausedCallback();
			return true;
		}
		if(input[1] == 6) {
			var slot = input[2];
			if(!ctrlKey) {
				this.loadPlayback(this.slots[slot]);
				this.resetLevel(slot);
				this.control.speed = 2;
				if(altKey) {
					this.control.pause();
				}
				this.control.silent = true;
				this.triggerPausedCallback();
				return true;
			}
			if(ctrlKey && !altKey) {
				this.control.pause();
				var video = this.recording.saveVideo(this.control.frame);
				console.log("[SAVE slot " + slot + "] @ " + this.control.frame);
				console.log("data: " + video.toString());
				this.slots[slot] = video;
				return true;
			}
		}
		return false;
	}
	,onScene: function(name) {
		console.log("[SCENE " + name + "]");
		if(this.fullgameVideo != null && Reflect.field(this.fullgameVideo,name) != null) {
			this.loadPlayback(new Video(Reflect.field(this.fullgameVideo,name)));
			this.control.paused = false;
			this.control.frame = 0;
			this.control.speed = 1;
			this.primeControls(false);
		}
	}
};
var CoffeeInput = { __ename__ : true, __constructs__ : ["StepFrame","Pause","PlaySlow","PlayNormal","PlayFast","Reset","Slot"] };
CoffeeInput.StepFrame = ["StepFrame",0];
CoffeeInput.StepFrame.__enum__ = CoffeeInput;
CoffeeInput.Pause = ["Pause",1];
CoffeeInput.Pause.__enum__ = CoffeeInput;
CoffeeInput.PlaySlow = ["PlaySlow",2];
CoffeeInput.PlaySlow.__enum__ = CoffeeInput;
CoffeeInput.PlayNormal = ["PlayNormal",3];
CoffeeInput.PlayNormal.__enum__ = CoffeeInput;
CoffeeInput.PlayFast = ["PlayFast",4];
CoffeeInput.PlayFast.__enum__ = CoffeeInput;
CoffeeInput.Reset = ["Reset",5];
CoffeeInput.Reset.__enum__ = CoffeeInput;
CoffeeInput.Slot = function(code) { var $x = ["Slot",6,code]; $x.__enum__ = CoffeeInput; return $x; };
var KeyBindings = function() { };
KeyBindings.__name__ = true;
KeyBindings.fromKeyCode = function(code) {
	switch(code) {
	case 65:
		return haxe_ds_Option.Some(CoffeeInput.Pause);
	case 68:
		return haxe_ds_Option.Some(CoffeeInput.PlayNormal);
	case 70:
		return haxe_ds_Option.Some(CoffeeInput.PlayFast);
	case 82:
		return haxe_ds_Option.Some(CoffeeInput.Reset);
	case 83:
		return haxe_ds_Option.Some(CoffeeInput.PlaySlow);
	case 90:
		return haxe_ds_Option.Some(CoffeeInput.StepFrame);
	default:
		if(code >= 48 && code <= 57) {
			return haxe_ds_Option.Some(CoffeeInput.Slot(code - 48));
		} else {
			return haxe_ds_Option.None;
		}
	}
};
var Main = function() { };
Main.__name__ = true;
Main.infoTrace = function(str) {
	console.log("    " + str);
};
Main.main = function() {
	console.log("  _____           _              _      _____       __  __          \n |_   _|         | |            | |    / ____|     / _|/ _|         \n   | |  _ __  ___| |_ __ _ _ __ | |_  | |     ___ | |_| |_ ___  ___ \n   | | | '_ \\/ __| __/ _` | '_ \\| __| | |    / _ \\|  _|  _/ _ \\/ _ \\\n  _| |_| | | \\__ \\ || (_| | | | | |_  | |___| (_) | | | ||  __/  __/\n |_____|_| |_|___/\\__\\__,_|_| |_|\\__|  \\_____\\___/|_| |_| \\___|\\___|");
	console.log("Instant Coffee is enabled.");
	Main.infoTrace("[r] to reset and pause.");
	Main.infoTrace("[a-s-d] to adjust playback.");
	Main.infoTrace("[z] to step frame.");
	Main.infoTrace("[0-9] to reset and play back video.");
	Main.infoTrace("ctrl+[0-9] to save video.");
	Main.infoTrace("alt+[0-9] to play back video, pausing on frame 1.");
	Main.infoTrace("[p] to reset and play the video in slot 0 in realtime");
	Main.infoTrace("`window.load(string)` to read video.");
	Main.infoTrace("`window.start{Left,Neutral,Right}()` to configure inputs on frame 0.");
	var engine = new Engine();
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
var Util = function() { };
Util.__name__ = true;
Util.isSome = function(x) {
	switch(x[1]) {
	case 0:
		return true;
	case 1:
		return false;
	}
};
var Video = function(save) {
	this.initialDirection = 0;
	this.pauseFrame = 0;
	this.actions = [];
	if(save != null) {
		var reader = new BSReader(save);
		var saveSize = this.getOption(reader.readInt(12));
		this.initialDirection = this.getOption(reader.readInt(12));
		this.pauseFrame = this.getOption(reader.readInt(Video.headerSize));
		var frame = 0;
		var _g1 = 0;
		var _g = saveSize;
		while(_g1 < _g) {
			var i = _g1++;
			var longDelay = this.getOption(reader.read(1))[0];
			var delay = this.getOption(reader.readInt(longDelay ? Video.longDelaySize : Video.delaySize));
			var code = this.getOption(reader.readInt(3));
			var down = this.getOption(reader.read(1));
			frame += delay;
			this.actions.push({ frame : frame, code : code, down : down[0]});
		}
	}
};
Video.__name__ = true;
Video.toActionCode = function(keyCode) {
	var _g1 = 0;
	var _g = Video.keyCodes.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(Video.keyCodes[i] == keyCode) {
			return haxe_ds_Option.Some(i);
		}
	}
	return haxe_ds_Option.None;
};
Video.fromActionCode = function(actionCode) {
	return Video.keyCodes[actionCode];
};
Video.showActionCode = function(actionCode) {
	switch(actionCode) {
	case 0:
		return "left   ";
	case 1:
		return "up     ";
	case 2:
		return "right  ";
	case 3:
		return "down   ";
	case 4:
		return "action ";
	case 5:
		return "space  ";
	}
	return "???    ";
};
Video.prototype = {
	getOption: function(x) {
		switch(x[1]) {
		case 0:
			var x1 = x[2];
			return x1;
		case 1:
			throw new js__$Boot_HaxeError("Invalid video string.");
			break;
		}
	}
	,toString: function() {
		var writer = new BSWriter();
		writer.writeInt(this.actions.length,12);
		writer.writeInt(this.initialDirection,12);
		writer.writeInt(this.pauseFrame,Video.headerSize);
		var lastFrame = 0;
		var _g = 0;
		var _g1 = this.actions;
		while(_g < _g1.length) {
			var action = _g1[_g];
			++_g;
			var delay = action.frame - lastFrame;
			lastFrame = action.frame;
			var longDelay = delay >= 32;
			writer.write([longDelay]);
			writer.writeInt(delay,longDelay ? Video.longDelaySize : Video.delaySize);
			writer.writeInt(action.code,3);
			writer.write([action.down]);
		}
		return writer.toString();
	}
	,copy: function() {
		var video = new Video();
		video.actions = this.actions.slice();
		video.pauseFrame = this.pauseFrame;
		video.initialDirection = this.initialDirection;
		return video;
	}
};
var VideoRecorder = function(initialDirection) {
	this.video = new Video();
	this.keyStates = [];
	var _g1 = 0;
	var _g = Video.keyCodes.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.keyStates.push(false);
	}
	this.video.initialDirection = initialDirection;
};
VideoRecorder.__name__ = true;
VideoRecorder.prototype = {
	recordKey: function(frame,keyCode,down,silent) {
		var _g = Video.toActionCode(keyCode);
		switch(_g[1]) {
		case 0:
			var action = _g[2];
			var oldState = this.keyStates[action];
			if(down == oldState) {
				return;
			}
			this.keyStates[action] = down;
			if(frame > 0) {
				this.video.actions.push({ frame : frame, code : action, down : down});
			}
			if(!silent) {
				console.log("---> " + Video.showActionCode(action) + " " + (down ? "down" : "up  ") + " @ " + frame);
			}
			break;
		case 1:
			return;
		}
	}
	,saveVideo: function(frame) {
		var res = this.video.copy();
		res.pauseFrame = frame;
		return res;
	}
};
var VideoPlayer = function(video) {
	this.video = video.copy();
};
VideoPlayer.__name__ = true;
VideoPlayer.prototype = {
	getActions: function(frame) {
		var res = [];
		while(this.video.actions.length > 0 && this.video.actions[0].frame == frame) {
			var action = this.video.actions.shift();
			res.push({ code : Video.fromActionCode(action.code), down : action.down});
		}
		return res;
	}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
var haxe_ds_Option = { __ename__ : true, __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Video.headerSize = 24;
Video.delaySize = 5;
Video.longDelaySize = 10;
Video.keyCodes = [37,38,39,40,88,32];
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Main.main();
})();
