// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var BSHead = function() {
	this.bitIndex = 0;
	this.blockIndex = 0;
};
BSHead.__name__ = true;
BSHead.prototype = {
	read: function(data) {
		if(data.length <= this.blockIndex) {
			return haxe_ds_Option.None;
		} else {
			return haxe_ds_Option.Some((data[this.blockIndex] >> this.bitIndex & 1) == 1);
		}
	}
	,write: function(data,value) {
		while(data.length <= this.blockIndex) data.push(0);
		if(value) {
			data[this.blockIndex] |= 1 << this.bitIndex;
		}
	}
	,increment: function() {
		this.bitIndex += 1;
		if(this.bitIndex > 5) {
			this.bitIndex = 0;
			this.blockIndex += 1;
		}
	}
};
var BSWriter = function() {
	this.head = new BSHead();
	this.data = [];
};
BSWriter.__name__ = true;
BSWriter.prototype = {
	toString: function() {
		var str = "";
		var _g = 0;
		var _g1 = this.data;
		while(_g < _g1.length) {
			var digit = _g1[_g];
			++_g;
			str += haxe_crypto_Base64.CHARS.charAt(digit);
		}
		return str;
	}
	,writeInt: function(value,bits) {
		var _g1 = 0;
		var _g = bits;
		while(_g1 < _g) {
			var i = _g1++;
			this.write([(value >> i & 1) == 1]);
		}
	}
	,write: function(values) {
		var _g = 0;
		while(_g < values.length) {
			var value = values[_g];
			++_g;
			this.head.write(this.data,value);
			this.head.increment();
		}
	}
};
var BSReader = function(encoded) {
	this.head = new BSHead();
	this.data = [];
	var _g1 = 0;
	var _g = encoded.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.data.push(this.charToInt(encoded.charAt(i)));
	}
};
BSReader.__name__ = true;
BSReader.prototype = {
	charToInt: function($char) {
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			if(haxe_crypto_Base64.CHARS.charAt(i) == $char) {
				return i;
			}
		}
		throw new js__$Boot_HaxeError("base64 out of bounds");
	}
	,read: function(length) {
		var bits = [];
		var _g1 = 0;
		var _g = length;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = this.head.read(this.data);
			switch(_g2[1]) {
			case 0:
				var bit = _g2[2];
				bits.push(bit);
				break;
			case 1:
				return haxe_ds_Option.None;
			}
			this.head.increment();
		}
		return haxe_ds_Option.Some(bits);
	}
	,readInt: function(length) {
		var _g = this.read(length);
		switch(_g[1]) {
		case 0:
			var bits = _g[2];
			var sum = 0;
			var _g1 = 0;
			var _g2 = length;
			while(_g1 < _g2) {
				var i = _g1++;
				sum += (bits[i] ? 1 : 0) << i;
			}
			return haxe_ds_Option.Some(sum);
		case 1:
			return haxe_ds_Option.None;
		}
	}
};
var PlayControl = function() {
	this.silent = false;
	this.speed = 0;
	this.paused = false;
	this.frame = 0;
};
PlayControl.__name__ = true;
PlayControl.prototype = {
	pause: function() {
		this.paused = true;
		this.speed = 0;
	}
};
var Engine = function() {
	this.initialDirection = 0;
	this.fakeTime = 0;
	this.pausedCallback = haxe_ds_Option.None;
	this.fullgameVideo = null;
	this.fullgameLevelCounter = 0;
	this.recording = new VideoRecorder(0);
	this.playback = haxe_ds_Option.None;
	this.control = new PlayControl();
	this.frameLength = 16;
	var _gthis = this;
	this._requestAnimationFrame = ($_=window,$bind($_,$_.requestAnimationFrame));
	this._now = ($_=window.performance,$bind($_,$_.now));
	window.requestAnimationFrame = $bind(this,this.requestAnimationFrame);
	window.performance.now = function() {
		return _gthis.fakeTime;
	};
	window._keyup = $bind(this,this.keyup);
	window._keydown = $bind(this,this.keydown);
	window.load = function(string) {
		_gthis.slots[0] = new Video(string);
	};
	window.loadFullgame = function(string1) {
		_gthis.fullgameVideo = string1.split(",").map(function(videoString) {
			return new Video(videoString);
		});
	};
	window.startLeft = function() {
		_gthis.initialDirection = 1;
	};
	window.startRight = function() {
		_gthis.initialDirection = 2;
	};
	window.startNeutral = function() {
		_gthis.initialDirection = 0;
	};
	window.useFrame = function(fl) {
		_gthis.frameLength = fl;
	};
	window.coffee = { };
	window.coffee.onScene = $bind(this,this.onScene);
	this.fakeTime = this._now();
	this.slots = [];
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		this.slots.push(new Video());
	}
	this.control.speed = 1;
};
Engine.__name__ = true;
Engine.prototype = {
	wrapCallback: function(callback) {
		var _gthis = this;
		return function() {
			_gthis.fakeTime += _gthis.frameLength;
			var _g = _gthis.playback;
			switch(_g[1]) {
			case 0:
				var player = _g[2];
				var _g1 = 0;
				var _g11 = player.getActions(_gthis.control.frame);
				while(_g1 < _g11.length) {
					var action = _g11[_g1];
					++_g1;
					_gthis.sendGameInput(action.code,action.down);
				}
				if(_gthis.control.frame + 1 >= player.video.pauseFrame) {
					if(_gthis.fullgameVideo == null) {
						_gthis.control.pause();
						console.log("[PAUSE] @ " + (_gthis.control.frame + 1));
						_gthis.control.silent = false;
					} else if(_gthis.fullgameLevelCounter >= 1 && _gthis.fullgameLevelCounter < 15) {
						_gthis.initialDirection = _gthis.fullgameVideo[_gthis.fullgameLevelCounter].initialDirection;
						_gthis.control.frame = 0;
						_gthis.primeControls(true);
					}
					_gthis.playback = haxe_ds_Option.None;
				}
				callback(_gthis.fakeTime);
				break;
			case 1:
				callback(_gthis.fakeTime);
				break;
			}
			_gthis.control.frame += 1;
		};
	}
	,requestAnimationFrame: function(callback) {
		var wrappedCallback = this.wrapCallback(callback);
		if(!this.control.paused) {
			var _g = this.control.speed;
			switch(_g) {
			case 0:
				window.setTimeout(wrappedCallback,100);
				break;
			case 1:
				this._requestAnimationFrame(wrappedCallback);
				break;
			default:
				window.setTimeout(wrappedCallback,0);
			}
		} else {
			this.pausedCallback = haxe_ds_Option.Some(wrappedCallback);
		}
	}
	,triggerPausedCallback: function() {
		var _g = this.pausedCallback;
		switch(_g[1]) {
		case 0:
			var cb = _g[2];
			this.pausedCallback = haxe_ds_Option.None;
			cb();
			break;
		case 1:
			break;
		}
	}
	,keyup: function(callback) {
		var _gthis = this;
		this.keyupHandler = callback;
		window.onkeyup = function(key) {
			_gthis.onKey(key,false);
		};
	}
	,keydown: function(callback) {
		var _gthis = this;
		this.keydownHandler = callback;
		window.onkeydown = function(key) {
			_gthis.onKey(key,true);
		};
	}
	,onKey: function(event,down) {
		if(!Util.isSome(this.playback)) {
			var suppress = [83,87,65,68,82];
			if(suppress.indexOf(event.keyCode) == -1) {
				this.sendGameInput(event.keyCode,down);
			}
		}
		if(down && this.fullgameVideo == null) {
			if(this.handleInterfaceInput(event.keyCode,event.ctrlKey)) {
				event.preventDefault();
			}
		}
	}
	,sendGameInput: function(keyCode,down) {
		this.recording.recordKey(this.control.frame,keyCode,down,this.control.silent);
		var event = { which : keyCode, preventDefault : function() {
		}};
		if(down) {
			this.keydownHandler(event);
		} else {
			this.keyupHandler(event);
		}
	}
	,primeControls: function(buffer) {
		var _g = 0;
		var _g1 = Video.keyCodes;
		while(_g < _g1.length) {
			var code = _g1[_g];
			++_g;
			this.sendGameInput(code,false);
		}
		if(this.initialDirection == 1) {
			if(buffer) {
				console.log("---> Holding controls: LEFT.");
			}
			this.sendGameInput(37,true);
		}
		if(this.initialDirection == 2) {
			if(buffer) {
				console.log("---> Holding controls: RIGHT.");
			}
			this.sendGameInput(39,true);
		}
		if(this.initialDirection == 0) {
			if(buffer) {
				console.log("---> Holding controls: NONE.");
			}
		}
	}
	,resetLevel: function(slot,replay) {
		if(replay == null) {
			replay = false;
		}
		console.log("[" + (replay ? "REPLAY" : "RESET to") + " " + (slot == null ? "start" : "slot " + (slot == null ? "null" : "" + slot) + "...") + "]");
		this.sendGameInput(82,true);
		this.sendGameInput(82,false);
		this.recording = new VideoRecorder(this.initialDirection);
		this.control = new PlayControl();
		this.primeControls(true);
	}
	,loadPlayback: function(video) {
		this.playback = haxe_ds_Option.Some(new VideoPlayer(video));
		this.initialDirection = video.initialDirection;
		this.recording = new VideoRecorder(this.initialDirection);
	}
	,handleInterfaceInput: function(keyCode,ctrlKey) {
		if(keyCode == 90 && this.control.paused) {
			this.triggerPausedCallback();
			return true;
		}
		var oldControl = JSON.parse(JSON.stringify(this.control));
		if(keyCode == 65) {
			if(!oldControl.paused) {
				console.log("[PAUSE] @ " + (this.control.frame + 1));
			}
			this.control.pause();
			return true;
		}
		if(keyCode == 83 || keyCode == 68 || keyCode == 70) {
			this.control.paused = false;
			switch(keyCode) {
			case 68:
				this.control.speed = 1;
				break;
			case 83:
				this.control.speed = 0;
				break;
			default:
				this.control.speed = 2;
			}
			if(oldControl.paused) {
				console.log("[PLAY] @ " + this.control.frame);
			}
			this.triggerPausedCallback();
			return true;
		}
		if(keyCode == 82) {
			this.playback = haxe_ds_Option.None;
			this.resetLevel();
			this.control.pause();
			this.triggerPausedCallback();
			return true;
		}
		if(!ctrlKey && keyCode >= 48 && keyCode <= 57) {
			var slot = keyCode - 48;
			this.loadPlayback(this.slots[slot]);
			this.resetLevel(slot);
			this.control.speed = 2;
			this.control.silent = true;
			this.triggerPausedCallback();
			return true;
		}
		if(keyCode == 80) {
			this.loadPlayback(this.slots[0]);
			this.resetLevel(0,true);
			this.control.speed = 1;
			this.triggerPausedCallback();
			return true;
		}
		if(ctrlKey && keyCode >= 48 && keyCode <= 57) {
			this.control.pause();
			var slot1 = keyCode - 48;
			var video = this.recording.saveVideo(this.control.frame);
			console.log("[SAVE slot " + slot1 + "] @ " + this.control.frame);
			console.log("data: " + video.toString());
			this.slots[slot1] = video;
			return true;
		}
		return false;
	}
	,onScene: function(name) {
		if(this.fullgameVideo != null && name.charAt(0) == "L") {
			this.fullgameLevelCounter = Std.parseInt(name.slice(5,10));
			this.loadPlayback(this.fullgameVideo[this.fullgameLevelCounter - 1]);
			this.control.paused = false;
			this.control.frame = 0;
			this.control.speed = 1;
			this.primeControls(false);
		}
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
var Main = function() { };
Main.__name__ = true;
Main.infoTrace = function(str) {
	console.log("    " + str);
};
Main.main = function() {
	console.log("  _____           _              _      _____       __  __          \n |_   _|         | |            | |    / ____|     / _|/ _|         \n   | |  _ __  ___| |_ __ _ _ __ | |_  | |     ___ | |_| |_ ___  ___ \n   | | | '_ \\/ __| __/ _` | '_ \\| __| | |    / _ \\|  _|  _/ _ \\/ _ \\\n  _| |_| | | \\__ \\ || (_| | | | | |_  | |___| (_) | | | ||  __/  __/\n |_____|_| |_|___/\\__\\__,_|_| |_|\\__|  \\_____\\___/|_| |_| \\___|\\___|");
	console.log("Instant Coffee is enabled.");
	Main.infoTrace("[r] to load initial state.");
	Main.infoTrace("[a-s-d] to adjust playback.");
	Main.infoTrace("[z] to step frame.");
	Main.infoTrace("ctrl+[0-9] to set save.");
	Main.infoTrace("[0-9] to load save.");
	Main.infoTrace("[p] to play the save in slot 0 in realtime");
	Main.infoTrace("`window.load(string)` to read savestate. You should be already on the correct level.");
	Main.infoTrace("`window.start{Left,Neutral,Right}()` to start the level with a direction key already pressed.");
	var engine = new Engine();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var Util = function() { };
Util.__name__ = true;
Util.isSome = function(x) {
	switch(x[1]) {
	case 0:
		return true;
	case 1:
		return false;
	}
};
var Video = function(save) {
	this.initialDirection = 0;
	this.pauseFrame = 0;
	this.actions = [];
	if(save != null) {
		var reader = new BSReader(save);
		var saveSize = this.getOption(reader.readInt(12));
		this.initialDirection = this.getOption(reader.readInt(12));
		this.pauseFrame = this.getOption(reader.readInt(Video.headerSize));
		var frame = 0;
		var _g1 = 0;
		var _g = saveSize;
		while(_g1 < _g) {
			var i = _g1++;
			var longDelay = this.getOption(reader.read(1))[0];
			var delay = this.getOption(reader.readInt(longDelay ? Video.longDelaySize : Video.delaySize));
			var code = this.getOption(reader.readInt(2));
			var down = this.getOption(reader.read(1));
			frame += delay;
			this.actions.push({ frame : frame, code : code, down : down[0]});
		}
	}
};
Video.__name__ = true;
Video.toActionCode = function(keyCode) {
	var _g = 0;
	while(_g < 4) {
		var i = _g++;
		if(Video.keyCodes[i] == keyCode) {
			return haxe_ds_Option.Some(i);
		}
	}
	return haxe_ds_Option.None;
};
Video.fromActionCode = function(actionCode) {
	return Video.keyCodes[actionCode];
};
Video.showActionCode = function(actionCode) {
	switch(actionCode) {
	case 0:
		return "left ";
	case 1:
		return "jump ";
	case 2:
		return "right";
	case 3:
		return "axe  ";
	}
	return "???";
};
Video.prototype = {
	getOption: function(x) {
		switch(x[1]) {
		case 0:
			var x1 = x[2];
			return x1;
		case 1:
			throw new js__$Boot_HaxeError("Invalid video string.");
			break;
		}
	}
	,toString: function() {
		var writer = new BSWriter();
		writer.writeInt(this.actions.length,12);
		writer.writeInt(this.initialDirection,12);
		writer.writeInt(this.pauseFrame,Video.headerSize);
		var lastFrame = 0;
		var _g = 0;
		var _g1 = this.actions;
		while(_g < _g1.length) {
			var action = _g1[_g];
			++_g;
			var delay = action.frame - lastFrame;
			lastFrame = action.frame;
			var longDelay = delay >= 32;
			writer.write([longDelay]);
			writer.writeInt(delay,longDelay ? Video.longDelaySize : Video.delaySize);
			writer.writeInt(action.code,2);
			writer.write([action.down]);
		}
		return writer.toString();
	}
	,copy: function() {
		var video = new Video();
		video.actions = this.actions.slice();
		video.pauseFrame = this.pauseFrame;
		video.initialDirection = this.initialDirection;
		return video;
	}
};
var VideoRecorder = function(initialDirection) {
	this.video = new Video();
	this.keyStates = [];
	var _g1 = 0;
	var _g = Video.keyCodes.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.keyStates.push(false);
	}
	this.video.initialDirection = initialDirection;
};
VideoRecorder.__name__ = true;
VideoRecorder.prototype = {
	recordKey: function(frame,keyCode,down,silent) {
		var _g = Video.toActionCode(keyCode);
		switch(_g[1]) {
		case 0:
			var action = _g[2];
			var oldState = this.keyStates[action];
			if(down == oldState) {
				return;
			}
			this.keyStates[action] = down;
			if(frame > 0) {
				this.video.actions.push({ frame : frame, code : action, down : down});
			}
			if(!silent) {
				console.log("---> " + Video.showActionCode(action) + " " + (down ? "down" : "up  ") + " @ " + frame);
			}
			break;
		case 1:
			return;
		}
	}
	,saveVideo: function(frame) {
		var res = this.video.copy();
		res.pauseFrame = frame;
		return res;
	}
};
var VideoPlayer = function(video) {
	this.video = video.copy();
};
VideoPlayer.__name__ = true;
VideoPlayer.prototype = {
	getActions: function(frame) {
		var res = [];
		while(this.video.actions.length > 0 && this.video.actions[0].frame == frame) {
			var action = this.video.actions.shift();
			res.push({ code : Video.fromActionCode(action.code), down : action.down});
		}
		return res;
	}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
var haxe_ds_Option = { __ename__ : true, __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Video.headerSize = 24;
Video.delaySize = 5;
Video.longDelaySize = 10;
Video.keyCodes = [37,38,39,88];
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Main.main();
})();
